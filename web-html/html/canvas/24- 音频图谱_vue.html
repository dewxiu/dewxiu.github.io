<!DOCTYPE html>
<html lang="en">
  <head>
    <header name="Access-Control-Allow-Origin" value="*" />
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="../../../assets/cssbem.css" />
    <script src="../../../assets/utils.js"></script>
    <script src="../../../assets/vue/vue3.global.js"></script>

    <style>
      .container {
        padding: 15px;
      }

      .play-btn {
        border: 1px solid transparent;
        font-size: 12px;
        padding: 2px 14px;
        border-radius: 20px;
        margin-right: 15px;
        overflow: hidden;
        display: inline-block;
        cursor: pointer;
        color: #fff;
        background-color: #1677ff;
      }

      .length {
        width: 80px;
      }

      .length span {
        font-size: 12px;
        display: inline-block;
        width: 32px;
      }

      .audio-track {
        width: 100%;
        height: 100%;
      }

      .audioTrack {
        margin-top: 5px;
        position: relative;
        width: 100%;
        min-height: 60px;
        font-size: 0;
        background-color: #d7d0fd;
      }

      .play-wave {
        width: 100%;
      }
      .play-wave canvas {
        background-color: #d7d0fd;
      }
    </style>
  </head>

  <body>
    <div id="app">
      <div class="container">
        <div class="flex just-between align-center">
          <button class="play-btn" @click="play">{{playText}}</button>
          <select name="speed" @change="onSpeedChange">
            <option v-for="item in playRateList" :value="item">{{item}}x</option>
          </select>
          <div class="length"><span>{{audioTime.currentMs}}</span><span>/{{audioTime.totalMs}}</span></div>
        </div>
        <div ref="audioTrack" class="audioTrack"></div>
        <boy-component :audio="audio" :flag="isPlay"></boy-component>
      </div>
    </div>
    <!-- <audio id="audio" src="http://media.mizuiren.com/cz.mp3"></audio> -->
    <script type="text/javascript">
      // https://cn.vuejs.org/guide/quick-start.html#using-vue-from-cdn
      var boyComponent = {
        props: {
          audio: { required: true },
          flag: { type: Boolean, required: true },
        },
        data() {
          return {
            oAudio: null,
            frameID: null,
            analyser: null,
            color: null,
            ctx: null,
            dataArray: [],
            bufferLength: [],
            oW: 0,
            oH: 0,
            barWidth: 4, // 波形条宽
            barGap: 4, // 波形条宽
            info: "当前歌曲",
          };
        },
        watch: {
          audio(v) {
            this.oAudio = v;
            if (!v) return;
            this.init();
          },
          flag(play) {
            if (!play) {
              this.draw();
              console.log("11", 11);
            } else {
              console.log("22", 22);
              cancelAnimationFrame(this.frameID);
            }
          },
        },
        computed: {
          status() {
            return this.flag === "播放" ? "暂停" : "播放";
          },
        },
        mounted() {},
        methods: {
          init() {
            const playWave = this.$refs.playWave;
            const canvas = this.$refs.amplitude;
            const rect = playWave.getBoundingClientRect();
            const context = new AudioContext();
            context.crossOrigin = "anonymous";
            const audioSrc = context.createMediaElementSource(this.oAudio);
            this.analyser = context.createAnalyser();
            audioSrc.connect(this.analyser);
            this.analyser.connect(context.destination);
            //根据范围得到不同音频的数量的长度
            this.bufferLength = this.analyser.frequencyBinCount;
            this.dataArray = new Uint8Array(this.bufferLength);

            this.ctx = canvas.getContext("2d");
            canvas.width = rect.width;
            canvas.height = 150;
            this.oW = canvas.width;
            this.oH = canvas.height;
            // canvas线性渐变
            this.color = this.ctx.createLinearGradient(this.oW / 2, this.oH / 2 - 30, this.oW / 2, this.oH / 2 + 10);
            this.color.addColorStop(0, "#0f0");
            this.color.addColorStop(1, "#f6f");
          },
          draw() {
            // 方法1:4个部分拼接的图谱
            this.analyser.getByteFrequencyData(this.dataArray);
            const count = this.oW / (this.barGap + this.barWidth) + 10; // 条数:总宽度÷(间隙+条宽)+偏移量
            const step = Math.round(this.dataArray.length / count);
            const bar_w = this.oW / this.bufferLength;
            this.ctx.clearRect(0, 0, this.oW, this.oH);
            const energy = 0.2;
            for (let i = 0; i < count; i++) {
              const audioHeight = this.dataArray[step * i];
              this.ctx.fillStyle = this.color;
              // 正向波形
              this.ctx.fillRect(this.oW / 2 + i * this.barGap, this.oH / 2, this.barWidth, -audioHeight * energy);
              this.ctx.fillRect(this.oW / 2 - i * this.barGap, this.oH / 2, this.barWidth, -audioHeight * energy);
              // 倒置波形
              this.ctx.fillRect(this.oW / 2 + i * this.barGap, this.oH / 2, this.barWidth, audioHeight * energy);
              this.ctx.fillRect(this.oW / 2 - i * this.barGap, this.oH / 2, this.barWidth, audioHeight * energy);
            }

            // 方法2:左右拼接的图谱
            // this.analyser.getByteFrequencyData(this.dataArray);
            // const count = this.oW / (this.barGap + this.barWidth) + 20;
            // this.ctx.clearRect(0, 0, this.oW, this.oH);
            // const bar_w = this.oW / this.bufferLength;
            // for (let i = 0; i < this.bufferLength / 4; i++) {
            //   let bar_x = this.oW / 2 + i * bar_w;
            //   let bar_h = (this.dataArray[i] / 255) * this.oH;
            //   let bar_y = this.oH - bar_h;
            //   this.ctx.fillStyle = this.color;
            //   // 绘制右边
            //   this.ctx.fillRect(bar_x, bar_y / 2, bar_w, bar_h);
            //   // 绘制左边
            //   this.ctx.fillRect(this.oW / 2 - i * bar_w, bar_y / 2, bar_w, bar_h);
            // }

            // console.log("this.dataArray", this.dataArray);
            this.frameID = requestAnimationFrame(this.draw);
          },
        },
        template: `
                <div>
                  <div>{{info}}{{status}}中...</div>
                  <div class="play-wave" ref="playWave">
                    <canvas ref="amplitude"></canvas>
                  </div>
                </div>
        `,
      };

      const { createApp } = Vue;

      createApp({
        components: { boyComponent },
        data() {
          return {
            audioUrl: "../../assets/media/cz.mp3", //'http://media.mizuiren.com/cz.mp3',
            waveCanvas: null,
            scanCanvas: null,
            waveCtx: null,
            audio: null,
            audioWidth: 0,
            audioHeight: 60,
            channelData: [],
            totalMs: 0,
            currentTime: 0,
            isPlay: true,
            playText: "播放",
            playbackRate: 1,
            playRateList: [1, 1.5, 2, 2.5, 3],
          };
        },
        mounted() {
          this.init();
          const mousedown = utils.isPC() ? "mousedown" : "touchstart";
          this.scanCanvas.addEventListener(mousedown, this.onMouseDown);
          document.addEventListener("keydown", (e) => {
            if (e.code === "Space") this.play();
          });
        },
        computed: {
          audioTime() {
            const currentMs = utils.toHHmmss(this.currentTime * 1000);
            const totalMs = utils.toHHmmss(this.totalMs * 1000);
            return { currentMs, totalMs };
          },
        },
        methods: {
          async init() {
            await this.createCanvasElement();
            await this.getAudioData();
          },
          onSpeedChange(e) {
            const rate = e.target.value || 1;
            this.audio.playbackRate = rate;
            this.playbackRate = rate;
          },
          createCanvasElement() {
            const rect = this.$refs.audioTrack.getBoundingClientRect();
            this.waveCanvas = document.createElement("canvas");
            this.scanCanvas = document.createElement("canvas");
            this.waveCtx = this.waveCanvas.getContext("2d");
            this.scanCtx = this.scanCanvas.getContext("2d");
            this.scanCanvas.style = `position: absolute;top: 0;left:0;z-index: 2;`;
            this.scanCanvas.width = this.waveCanvas.width = this.audioWidth = rect.width;
            this.scanCanvas.height = this.waveCanvas.height = this.audioHeight;
            this.$refs.audioTrack.appendChild(this.waveCanvas);
            this.$refs.audioTrack.appendChild(this.scanCanvas);
          },
          async getAudioData() {
            const arrayBuffer = await this.getAudioArrayBuffer(this.audioUrl); // 获取音频ArrayBuffer
            const audioBuffer = await new Promise((resolve, reject) => {
              // 获取音频AudioBuffer
              const context = new AudioContext();
              context.crossOrigin = "anonymous";
              context.decodeAudioData(arrayBuffer, resolve, reject);
            });
            this.createAudio(audioBuffer, this.audioUrl);
            this.channelData = audioBuffer.getChannelData(0); // 返回Float32Array 通道的PCM数据,0代表第一个通道
            if (this.channelData) this.drawTrack();
          },
          async getAudioArrayBuffer(audioUrl) {
            // 音频文件 ArrayBuffer
            const res = await fetch(audioUrl);
            return res.arrayBuffer();
          },
          drawTrack() {
            // 绘制音频图谱
            this.waveCtx.clearRect(0, 0, this.audioWidth, this.audioHeight);
            this.waveCtx.fillStyle = "rgb(0 22 237)";
            // 计算获取音频帧的集合，然后绘出每一帧
            const audioTrackList = this.getAudioTrackList(this.channelData, this.audioWidth);
            audioTrackList.forEach((item, index) => {
              if (index % 2) return;
              const barHeight = Math.max(1, item * this.audioHeight * 0.4);
              const barWidth = 1;
              this.waveCtx.fillRect(index, (this.audioHeight - barHeight) / 2, barWidth, barHeight);
            });
          },
          // 获取音频轨道数据
          getAudioTrackList(channelData, trackTotalWidth) {
            let i = 0;
            let min = 1;
            let max = -1;
            const list = [];
            let stepIndex = 0;
            const unitWidth = Math.floor(channelData.length / trackTotalWidth);
            while (stepIndex++ < trackTotalWidth) {
              min = 1;
              max = -1;
              const end = Math.min(stepIndex * unitWidth, channelData.length);
              while (i++ < end) {
                const current = channelData[i];
                if (current > max) max = current;
                if (current < min) min = current;
              }
              list.push(max - min);
            }
            return list;
          },
          // 播放音频
          createAudio(audioBuffer, audioUrl) {
            this.totalMs = audioBuffer?.duration;
            this.audio = new Audio();
            this.audio.crossOrigin = "anonymous";

            this.audio.loop = true;
            this.audio.src = audioUrl;
            this.audio.ontimeupdate = (e) => this.drawLine();
          },
          play() {
            if (this.isPlay) {
              this.audio.play();
              this.playText = "暂停";
            } else {
              this.audio.pause();
              this.playText = "播放";
            }
            this.isPlay = !this.isPlay;
          },
          onMouseDown(e) {
            this.onMouseMove(e);
            const mouseup = utils.isPC() ? "mouseup" : "touchend";
            const mousemove = utils.isPC() ? "mousemove" : "touchmove";
            document.addEventListener(mouseup, this.onMouseUp, false);
            document.addEventListener(mousemove, this.onMouseMove, false);
          },
          onMouseMove(e) {
            const rect = this.scanCanvas.getBoundingClientRect();
            const xx = utils.isPC() ? e.clientX - rect.left : e.touches[0].pageX - rect.left;
            this.drawLine(xx);
          },
          onMouseUp(e) {
            const mousedown = utils.isPC() ? "mousedown" : "touchstart";
            const mousemove = utils.isPC() ? "mousemove" : "touchmove";
            document.removeEventListener(mousedown, this.onMouseDown);
            document.removeEventListener(mousemove, this.onMouseMove);
          },
          drawLine(pos) {
            let x = pos;
            if (pos) {
              this.currentTime = (pos * this.totalMs) / this.audioWidth;
              this.audio.currentTime = this.currentTime;
            } else {
              this.currentTime = this.audio.currentTime;
              x = (this.currentTime / this.totalMs) * this.audioWidth;
            }
            this.scanCtx.clearRect(0, 0, this.audioWidth, this.audioHeight);
            this.scanCtx.fillStyle = "rgba(125,150,0,.3)";
            this.scanCtx.fillRect(0, 0, x, this.audioHeight);
          },
        },
      }).mount("#app");
    </script>
  </body>
</html>
